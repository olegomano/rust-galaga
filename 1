extern crate gl;
extern crate nalgebra_glm as glm;
use super::shader;
use super::vbo;
use super::gl_error;
use super::texture;
use super::material;

#[macro_use]
extern crate asset_gen;

static vert_shader : &str =  
    "#version 300 es
     uniform mat4 MVPMatrix;
     in vec4 vPosition;
     in vec2 vUv;

     out vec2 uv;
     void main() {
        uv = vUv;
        gl_Position = MVPMatrix * vPosition;
     }";

static frag_shader : &str =
    "#version 300 es
     precision mediump float;
     uniform vec4 vColor;
     uniform sampler2D tDiffuse;
     uniform sampler2D tDisplace;

     in vec2 uv;
     out vec4 FragColor;
     void main() { 
        FragColor = texture(tDiffuse,uv) + texture(tDisplace,uv);
     }";

static quad_vert : &[f32] = &[
    -0.5,-0.5,0.0,1.0,  0.0,0.0,
    -0.5, 0.5,0.0,1.0,  0.0,1.0,
     0.5, 0.5,0.0,1.0,  1.0,1.0,

     0.5, 0.5,0.0,1.0,  1.0, 1.0,
     0.5,-0.5,0.0,1.0,  1.0, 0.0,
    -0.5,-0.5,0.0,1.0,  0.0, 0.0
];


fn GetUniformLocation( program_id : gl::types::GLuint, name : &str) -> gl::types::GLint {
    let uniform = shader::FindUniform(program_id,name);
    match  uniform {
        Some(x) => {return x},
        None => {println!("Failed to find uniform {}",name); return 0}
    }
} 


fn GetAttributeLocation( program_id : gl::types::GLuint, name : &str) -> gl::types::GLint {
    let attr = shader::FindAttribute(program_id,name);
    match attr {
        Some(x) => {return x},
        None => {println!("Failed to find attribute {}",name); return 0;}
    }
} 

fn CompileShader(vertex : &str,  fragment : &str) -> Result<gl::types::GLuint, String> {
    return shader::Compile(vertex, fragment);
}

#[derive(Default)]
#[derive(asset_gen::GlBinding)]
pub struct GLBindings{
    u_model_matrix : gl::types::GLint,
    u_color : gl::types::GLint,
    t_diffuse : gl::types::GLint,
    t_displace : gl::types::GLint,
    a_vertex : gl::types::GLint,
    a_uv : gl::types::GLint,
    program_id : gl::types::GLuint,
}

pub struct SpriteShader{
    quad_vbo : vbo::Vbo,
    binding : GLBindings,
}

impl SpriteShader{
    pub fn new() -> Result<SpriteShader,String>
    {
        let vbo = vbo::Vbo::new(quad_vert);
        let mut binding : GLBindings = GLBindings::new(vert_shader,frag_shader).unwrap();
        binding.GlBind();
        return Ok(Self{
            quad_vbo : vbo,
            binding : binding,
        })
    }

    pub fn Render( 
            &mut self,
            transform : &glm::Mat4, 
            texture: &material::Material){

        self.shader.Enable();
        self.shader.UniformMat4(self.binding.u_model_matrix, transform);
        let color : glm::Vec4= glm::Vec4::new(1.0,1.0,1.0,1.0);
        self.quad_vbo.Bind();
        //self.shader.UniformVec4(self.u_color, &color);
        
        texture.Diffuse().Bind(gl::TEXTURE0);
        self.shader.Uniform1i(self.t_diffuse,0);
        texture.Displace().Bind(gl::TEXTURE1);
        self.shader.Uniform1i(self.t_displace,0);

        self.shader.Attribute(self.a_vertex as gl::types::GLuint , &self.quad_vbo.MakeView(0,4,24,146));
        self.shader.Attribute(self.a_uv as gl::types::GLuint , &self.quad_vbo.MakeView(16,2,24,146));
        
        unsafe{
            gl::DrawArrays(gl::TRIANGLES,0,6);
        }
        gl_error::PrintError(); 
    }
}
